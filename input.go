// Package solc
//
// @author: xwc1125
package solc

var (
	DefaultSetting = Settings{
		Optimizer: Optimizer{
			Enabled: false,
			Runs:    200,
		},
		EVMVersion: "byzantium",
		OutputSelection: map[string]map[string][]string{
			"*": map[string][]string{
				"*": []string{
					"abi",
					"evm.bytecode.object",
					"evm.bytecode.sourceMap",
					"evm.deployedBytecode.object",
					"evm.deployedBytecode.sourceMap",
					"evm.methodIdentifiers",
				},
				"": []string{
					"ast",
				},
			},
		},
	}
)

// Input 编译输入
type Input struct {
	Language string              `json:"language,omitempty"` // 编码语言
	Sources  map[string]SourceIn `json:"sources,omitempty"`  // 资源。xx.sol-->文件内内容
	Settings Settings            `json:"settings,omitempty"` // 设置
}

// SourceIn 资源输入
type SourceIn struct {
	Keccak256 string `json:"keccak256,omitempty"` // sol文件的keccak256值
	Content   string `json:"content,omitempty"`   // sol文本内容
}

// Settings 设置。此配置对应truffle-config.js中的compilers
// https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description
type Settings struct {
	Remappings []string  `json:"remappings,omitempty"` // 重新映射的排序列表
	Optimizer  Optimizer `json:"optimizer,omitempty"`  // 优化配置
	EVMVersion string    `json:"evmVersion,omitempty"` // evm版本
	// The following can be used to select desired outputs based
	// on file and contract names.
	// If this field is omitted, then the compiler loads and does type checking,
	// but will not generate any outputs apart from errors.
	// The first level key is the file name and the second level key is the contract name.
	// An empty contract name is used for outputs that are not tied to a contract
	// but to the whole source file like the AST.
	// A star as contract name refers to all contracts in the file.
	// Similarly, a star as a file name matches all files.
	// To select all outputs the compiler can possibly generate, use
	// "outputSelection: { "*": { "*": [ "*" ], "": [ "*" ] } }"
	// but note that this might slow down the compilation process needlessly.
	//
	// The available output types are as follows:
	//
	// File level (needs empty string as contract name):
	//   ast - AST of all source files
	//
	// Contract level (needs the contract name or "*"):
	//   abi - ABI
	//   devdoc - Developer documentation (natspec)
	//   userdoc - User documentation (natspec)
	//   metadata - Metadata
	//   ir - Yul intermediate representation of the code before optimization
	//   irOptimized - Intermediate representation after optimization
	//   storageLayout - Slots, offsets and types of the contract's state variables.
	//   evm.assembly - New assembly format
	//   evm.legacyAssembly - Old-style assembly format in JSON
	//   evm.bytecode.functionDebugData - Debugging information at function level
	//   evm.bytecode.object - Bytecode object
	//   evm.bytecode.opcodes - Opcodes list
	//   evm.bytecode.sourceMap - Source mapping (useful for debugging)
	//   evm.bytecode.linkReferences - Link references (if unlinked object)
	//   evm.bytecode.generatedSources - Sources generated by the compiler
	//   evm.deployedBytecode* - Deployed bytecode (has all the options that evm.bytecode has)
	//   evm.deployedBytecode.immutableReferences - Map from AST ids to bytecode ranges that reference immutables
	//   evm.methodIdentifiers - The list of function hashes
	//   evm.gasEstimates - Function gas estimates
	//   ewasm.wast - Ewasm in WebAssembly S-expressions format
	//   ewasm.wasm - Ewasm in WebAssembly binary format
	//
	// Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every
	// target part of that output. Additionally, `*` can be used as a wildcard to request everything.
	//
	OutputSelection map[string]map[string][]string `json:"outputSelection,omitempty"` // 输出选择器
}

// Optimizer 优化配置
type Optimizer struct {
	Enabled bool `json:"enabled,omitempty"` // 是否启动优化
	Runs    int  `json:"runs,omitempty"`    // 优化运行代码的次数。值越低，初始部署成本越高，优化效果越好
}
